<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Liturgia Live Display</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #live-container {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
    }
    #live-content {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      color: white;
      font-family: Arial, sans-serif;
      padding: 20px;
      box-sizing: border-box;
    }
    #live-number {
      font-size: 1.5em;
      align-self: flex-start;
      vertical-align: super;
      line-height: 1;
    }
    #live-text {
      font-size: 2em;
      text-align: center;
      flex: 1;
      overflow-wrap: break-word;
      word-break: break-word;
      max-width: 100%;
      padding: 0 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Inline verse number style for live multi-verse passages */
    #live-text p { margin: 0; }
    #live-text p sub.verse-num { font-size: 0.65em; vertical-align: sub; margin-right: 6px; opacity: 0.9; }
    #live-reference {
      font-size: 0.8em;
      align-self: flex-end;
      margin-top: auto;
    }
  </style>
</head>
<body>
  <canvas id="live-canvas" style="width: 100vw; height: 100vh; display: block;"></canvas>
  <canvas id="live-text-canvas" style="position:absolute;left:0;top:0;width:100vw;height:100vh;pointer-events:none;display:block;"></canvas>
  <script>
    const { ipcRenderer } = require('electron');
    
    const bgCanvas = document.getElementById('live-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const textCanvas = document.getElementById('live-text-canvas');
    const textCtx = textCanvas.getContext('2d');
    // Backwards-compatible aliases for older code that references `canvas`/`ctx`
    const canvas = bgCanvas;
    const ctx = bgCtx;
    
    // License watermark state (updated from main via ipc)
    let licenseStatus = { active: true };
    ipcRenderer.on('license-status', (event, status) => {
      licenseStatus = status || { active: false };
      // Refresh current content so watermark is placed under text
      refreshContentWithWatermark().catch(e => { console.error('Failed to refresh content for watermark:', e); });
    });

    // Initialize from main process stored status (if available)
    (async () => {
      try {
        const s = await ipcRenderer.invoke('get-current-license-status');
        if (s) { licenseStatus = s; await refreshContentWithWatermark(); }
      } catch (e) { /* ignore */ }
    })();

    // Render text content to an offscreen canvas and return it
    function renderTextToCanvas(content, width, height) {
      const textCanvas = document.createElement('canvas');
      textCanvas.width = width;
      textCanvas.height = height;
      const textCtx = textCanvas.getContext('2d');
      textCtx.clearRect(0, 0, width, height);
      const styles = content && content.styles ? content.styles : {};
      const textStyle = styles.text || {};
      const numberStyle = styles.number || styles.title || {};
      const referenceStyle = styles.reference || {};

      textCtx.textAlign = 'center';
      textCtx.textBaseline = 'middle';

      const padding = width * 0.02;
      const availableWidth = width - (padding * 2);
      const availableHeight = height - (padding * 2);
      let baseFontSize = height * 0.08;

      // Render verse number (top left)
      if (content.number) {
        textCtx.font = `${baseFontSize * 0.6}px Arial`;
        textCtx.textAlign = 'left';
        textCtx.fillStyle = numberStyle.color || '#fff';
        textCtx.fillText(content.number, padding, padding + baseFontSize * 0.3);
      }

      // Render verse text (center)
      if (content.text) {
        textCtx.textAlign = 'center';
        const textY = height / 2;
        const textLines = content.text.split('\n');
        const allLines = [];

        textLines.forEach(textLine => {
          const segments = parseVerseSegments(textLine);
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          textCtx.font = `${baseFontSize}px Arial`;
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
          allLines.push(...wrappedLines);
        });

        let lines = allLines;

        // Size adjustment (grow if space allows)
        while (true) {
          const testSize = baseFontSize + 4;
          textCtx.font = `${testSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, testSize, textCtx);
            testLines.push(...wrappedLines);
          });
          if (testLines.length * testSize * 1.2 < availableHeight * 0.85 && testSize < height * 0.15) {
            baseFontSize = testSize;
            lines = testLines;
          } else break;
        }

        // Shrink if needed
        while (lines.length * baseFontSize * 1.2 > availableHeight && baseFontSize > 20) {
          baseFontSize -= 2;
          textCtx.font = `${baseFontSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            // Ensure inline markdown is parsed for measurement
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
            testLines.push(...wrappedLines);
          });
          lines = testLines;
        }

        // Render lines
        const lineHeight = baseFontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        const startY = textY - (totalHeight / 2);

        lines.forEach((line, i) => {
          renderLineWithSubscripts(line, width / 2, startY + (i * lineHeight) + (baseFontSize / 2), baseFontSize, textCtx, { textColor: textStyle.color || '#fff', subscriptColor: textStyle.subscriptColor || (textStyle.color ? textStyle.color : '#ddd') });
        });
      }

      // Render reference (bottom right)
      if (content.reference) {
        textCtx.font = `${baseFontSize * 0.7}px Arial`;
        textCtx.textAlign = 'right';
        textCtx.fillStyle = referenceStyle.color || '#fff';
        textCtx.fillText(content.reference, width - padding, height - padding - baseFontSize * 0.3);
      }

      return textCanvas;
    }

    // Refresh the visible canvas so watermark is placed between background and text
    async function refreshContentWithWatermark() {
      if (!canvas || !ctx) return;
      if (!window.currentContent) {
        // Nothing to do but draw watermark over black
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawLicenseWatermark();
        return;
      }
      // Cancel any running animations
      if (currentAnimationFrameId) { cancelAnimationFrame(currentAnimationFrameId); currentAnimationFrameId = null; }
      const width = canvas.width;
      const height = canvas.height;

      // Render background to offscreen canvas
      const off = document.createElement('canvas'); off.width = width; off.height = height;
      await renderBackgroundToCanvas(window.currentContent, off);
      // Draw background
      ctx.drawImage(off, 0, 0);
      // Draw watermark between background and text
      drawLicenseWatermark();
      // Draw text if present
      if (window.currentContent && window.currentContent.text) {
        const txt = renderTextToCanvas(window.currentContent, width, height);
        ctx.drawImage(txt, 0, 0);
      }
    }

    function drawLicenseWatermark(targetCtx = bgCtx, targetCanvas = bgCanvas) {
      if (!targetCanvas || !targetCtx) { console.debug('[live] drawLicenseWatermark: no target'); return; }
      if (licenseStatus && licenseStatus.active) { console.debug('[live] drawLicenseWatermark: license active - skipping watermark'); return; } // nothing to draw
      console.debug('[live] drawLicenseWatermark: drawing watermark', { active: !!(licenseStatus && licenseStatus.active), width: targetCanvas.width, height: targetCanvas.height });
      targetCtx.save();
      // Large, semi-transparent central watermark (draw on background canvas)
      const minDim = Math.min(targetCanvas.width, targetCanvas.height);
      const bigSize = Math.floor(minDim * 0.2); // 20% of min dimension
      targetCtx.globalAlpha = 0.14;
      targetCtx.fillStyle = '#ffffff';
      targetCtx.textAlign = 'center';
      targetCtx.textBaseline = 'middle';
      targetCtx.translate(targetCanvas.width / 2, targetCanvas.height / 2);
      targetCtx.rotate(-0.25);

      // Draw main title
      targetCtx.font = `bold ${bigSize}px Arial`;
      targetCtx.fillText('LITURGIA', 0, 0);

      // Draw account/email beneath if available (smaller, fainter)
      const email = (licenseStatus && (licenseStatus.token_payload && licenseStatus.token_payload.email)) || (licenseStatus && licenseStatus.user_row && licenseStatus.user_row.email) || null;
      if (email) {
        targetCtx.globalAlpha = 0.10;
        targetCtx.font = `bold ${Math.max(14, Math.floor(bigSize * 0.28))}px Arial`;
        targetCtx.fillText(String(email).toUpperCase(), 0, Math.floor(bigSize * 0.9));
      } else {
        targetCtx.globalAlpha = 0.08;
        targetCtx.font = `bold ${Math.max(12, Math.floor(bigSize * 0.18))}px Arial`;
        targetCtx.fillText('UNLICENSED', 0, Math.floor(bigSize * 0.9));
      }

      targetCtx.restore();
    }

    // Track state for clear/black modes
    let isClearMode = false;
    let isBlackMode = false;
    
    // Set canvas to actual display resolution
    function resizeCanvas() {
      bgCanvas.width = window.screen.width;
      bgCanvas.height = window.screen.height;
      textCanvas.width = window.screen.width;
      textCanvas.height = window.screen.height;
      // Redraw based on current mode
      if (isBlackMode || isClearMode) {
        // Just fill with black on background and clear text layer
        bgCtx.fillStyle = '#000';
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        drawLicenseWatermark();
        textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      } else if (window.currentContent) {
        // Re-render full composition so watermark sits under text
        refreshContentWithWatermark().catch(e => console.error('resize refresh failed', e));
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    function drawImageWithSettings(ctx, img, canvasWidth, canvasHeight, settings = {}) {
      const bgSize = settings.bgSize || 'cover';
      const bgRepeat = settings.bgRepeat || 'no-repeat';
      const bgPosition = settings.bgPosition || 'center';
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      let drawWidth, drawHeight, scale;
      
      // Calculate dimensions based on background-size
      if (bgSize === 'cover') {
        scale = Math.max(canvasWidth / img.width, canvasHeight / img.height);
        drawWidth = img.width * scale;
        drawHeight = img.height * scale;
      } else if (bgSize === 'contain') {
        scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);
        drawWidth = img.width * scale;
        drawHeight = img.height * scale;
      } else if (bgSize === '100% 100%') {
        drawWidth = canvasWidth;
        drawHeight = canvasHeight;
      } else { // 'auto' - original size
        drawWidth = img.width;
        drawHeight = img.height;
      }
      
      // Calculate position
      let startX = 0, startY = 0;
      if (bgPosition.includes('center') || bgPosition === 'center') {
        startX = (canvasWidth - drawWidth) / 2;
        startY = (canvasHeight - drawHeight) / 2;
      } else {
        const positions = bgPosition.split(' ');
        const posX = positions[0] || 'center';
        const posY = positions[1] || 'center';
        
        if (posX === 'left') startX = 0;
        else if (posX === 'right') startX = canvasWidth - drawWidth;
        else if (posX === 'center') startX = (canvasWidth - drawWidth) / 2;
        
        if (posY === 'top') startY = 0;
        else if (posY === 'bottom') startY = canvasHeight - drawHeight;
        else if (posY === 'center') startY = (canvasHeight - drawHeight) / 2;
      }
      
      // Handle repeat
      if (bgRepeat === 'no-repeat') {
        ctx.drawImage(img, startX, startY, drawWidth, drawHeight);
      } else if (bgRepeat === 'repeat') {
        for (let x = startX % drawWidth - drawWidth; x < canvasWidth; x += drawWidth) {
          for (let y = startY % drawHeight - drawHeight; y < canvasHeight; y += drawHeight) {
            ctx.drawImage(img, x, y, drawWidth, drawHeight);
          }
        }
      } else if (bgRepeat === 'repeat-x') {
        for (let x = startX % drawWidth - drawWidth; x < canvasWidth; x += drawWidth) {
          ctx.drawImage(img, x, startY, drawWidth, drawHeight);
        }
      } else if (bgRepeat === 'repeat-y') {
        for (let y = startY % drawHeight - drawHeight; y < canvasHeight; y += drawHeight) {
          ctx.drawImage(img, startX, y, drawWidth, drawHeight);
        }
      }
    }
    
    function applyColorToCanvas(ctx, colorCSS, width, height) {
      // Check if it's a gradient
      if (colorCSS.startsWith('linear-gradient')) {
        // Parse linear-gradient(135deg, #667eea, #764ba2)
        const match = colorCSS.match(/linear-gradient\((\d+)deg,\s*([^,]+),\s*(.+)\)/);
        if (match) {
          const angle = parseInt(match[1]);
          const color1 = match[2].trim();
          const color2 = match[3].trim();
          
          // Convert angle to radians and calculate gradient direction
          const angleRad = (angle - 90) * Math.PI / 180;
          const x1 = width / 2 + Math.cos(angleRad) * width / 2;
          const y1 = height / 2 + Math.sin(angleRad) * height / 2;
          const x2 = width / 2 - Math.cos(angleRad) * width / 2;
          const y2 = height / 2 - Math.sin(angleRad) * height / 2;
          
          const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
          gradient.addColorStop(0, color1);
          gradient.addColorStop(1, color2);
          ctx.fillStyle = gradient;
        }
      } else if (colorCSS.startsWith('radial-gradient')) {
        // Parse radial-gradient(circle, #667eea, #764ba2)
        const match = colorCSS.match(/radial-gradient\(circle,\s*([^,]+),\s*(.+)\)/);
        if (match) {
          const color1 = match[1].trim();
          const color2 = match[2].trim();
          
          const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
          gradient.addColorStop(0, color1);
          gradient.addColorStop(1, color2);
          ctx.fillStyle = gradient;
        }
      } else {
        // Solid color
        ctx.fillStyle = colorCSS;
      }
      ctx.fillRect(0, 0, width, height);
    }
    
    /**
     * Apply fade-in animation to canvas
     */
    function applyFadeInAnimation(duration = 1.0, callback = null) {
      const startTime = Date.now();
      const originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      const animate = () => {
        const elapsed = (Date.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        
        // Create a copy of the image data with adjusted alpha
        const imageData = ctx.createImageData(originalImageData);
        const data = imageData.data;
        const originalData = originalImageData.data;
        
        // Adjust alpha channel for all pixels
        for (let i = 3; i < data.length; i += 4) {
          data[i] = Math.round(originalData[i] * progress);
        }
        
        // Clear canvas and redraw with faded image
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(imageData, 0, 0);
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          ctx.putImageData(originalImageData, 0, 0);
          // Ensure watermark is present after fade finishes
          drawLicenseWatermark();
          if (callback) callback();
        }
      };
      
      animate();
    }
    
    let currentRenderContent = null;
    let currentRenderWidth = 0;
    let currentRenderHeight = 0;
    
    /**
     * Apply fade-out animation to remove current text
     */
    function applyTextFadeOutAnimation(oldContent, duration = 1, animationType = 'fade', callback) {
      // Check if there's actually content to fade out
      if (!oldContent || !oldContent.text) {
        if (callback) callback();
        return;
      }

      const startTime = Date.now();
      const width = currentRenderWidth;
      const height = currentRenderHeight;
      
      // Capture the current BACKGROUND only (we'll fade out text separately)
      const backgroundImageData = ctx.getImageData(0, 0, width, height);
      
      // Pre-render the OLD text to an off-screen canvas (use same logic as fade-in)
      const textCanvas = document.createElement('canvas');
      textCanvas.width = width;
      textCanvas.height = height;
      const textCtx = textCanvas.getContext('2d');
      textCtx.clearRect(0, 0, width, height);
      
      // Render OLD text to off-screen canvas using proper wrapping
      const styles = oldContent && oldContent.styles ? oldContent.styles : {};
      const textStyle = styles.text || {};
      const numberStyle = styles.number || styles.title || {};
      const referenceStyle = styles.reference || {};

      textCtx.textAlign = 'center';
      textCtx.textBaseline = 'middle';
      
      const padding = width * 0.02;
      const availableWidth = width - (padding * 2);
      const availableHeight = height - (padding * 2);
      let baseFontSize = height * 0.08;
      
      // Render verse number (top left)
      if (oldContent.number) {
        textCtx.font = `${baseFontSize * 0.6}px Arial`;
        textCtx.textAlign = 'left';
        textCtx.fillStyle = numberStyle.color || '#fff';
        textCtx.fillText(oldContent.number, padding, padding + baseFontSize * 0.3);
      }
      
      // Render verse text (center) - use proper wrapping logic
      if (oldContent.text) {
        textCtx.textAlign = 'center';
        const textY = height / 2;
        const textLines = oldContent.text.split('\n');
        const allLines = [];
        
        textLines.forEach(textLine => {
          const segments = parseVerseSegments(textLine);
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          textCtx.font = `${baseFontSize}px Arial`;
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
          allLines.push(...wrappedLines);
        });
        
        let lines = allLines;
        
        // Size adjustment - grow font if space allows
        while (true) {
          const testSize = baseFontSize + 4;
          textCtx.font = `${testSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, testSize, textCtx);
            testLines.push(...wrappedLines);
          });
          if (testLines.length * testSize * 1.2 < availableHeight * 0.85 && testSize < height * 0.15) {
            baseFontSize = testSize;
            lines = testLines;
          } else {
            break;
          }
        }
        
        // Shrink font if needed
        while (lines.length * baseFontSize * 1.2 > availableHeight && baseFontSize > 20) {
          baseFontSize -= 2;
          textCtx.font = `${baseFontSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            // Ensure inline markdown is parsed for measurement
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
            testLines.push(...wrappedLines);
          });
          lines = testLines;
        }
        
        // Render lines with proper positioning
        const lineHeight = baseFontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        const startY = textY - (totalHeight / 2);
        
        lines.forEach((line, i) => {
          renderLineWithSubscripts(line, width / 2, startY + (i * lineHeight) + (baseFontSize / 2), baseFontSize, textCtx, { textColor: textStyle.color || '#fff', subscriptColor: textStyle.subscriptColor || (textStyle.color ? textStyle.color : '#ddd') });
        });
      }
      
      // Render reference (bottom right)
      if (oldContent.reference) {
        textCtx.font = `${baseFontSize * 0.7}px Arial`;
        textCtx.textAlign = 'right';
        textCtx.fillText(oldContent.reference, width - padding, height - padding - baseFontSize * 0.3);
      }

      // Easing helper (smooth acceleration/deceleration)
      function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; }

      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / (duration * 1000), 1);
        const eased = easeInOutCubic(progress);
        const reverseEased = 1 - eased; // For fade-out easing

        // Restore background first
        ctx.putImageData(backgroundImageData, 0, 0);

        // Draw watermark on top of background (so text fades out over it)
        drawLicenseWatermark();

        // Apply fade-out effect to TEXT ONLY (use eased values)
        if (animationType === 'fade') {
          ctx.globalAlpha = reverseEased;
          ctx.drawImage(textCanvas, 0, 0);
          ctx.globalAlpha = 1;
        } else if (animationType === 'slide-left') {
          // Slide out to left using fractional offset
          const offset = eased * width;
          ctx.drawImage(textCanvas, -offset, 0);
        } else if (animationType === 'slide-right') {
          // Slide out to right using fractional offset
          const offset = eased * width;
          ctx.drawImage(textCanvas, offset, 0);
        } else if (animationType === 'slide-up') {
          const offset = eased * height;
          ctx.drawImage(textCanvas, 0, -offset);
        } else if (animationType === 'slide-down') {
          const offset = eased * height;
          ctx.drawImage(textCanvas, 0, offset);
        }

        if (progress < 1) {
          currentAnimationFrameId = requestAnimationFrame(animate);
        } else {
          // Animation complete
          currentAnimationFrameId = null;
          if (callback) callback();
        }
      };

      // Run first frame synchronously to start animation immediately
      currentAnimationFrameId = requestAnimationFrame(animate);
    }
    
    /**
     * Apply text animation with support for fade and slide effects
     */
    function applyTextFadeInAnimation(duration = 1.0, animationType = 'fade', callback = null) {
      const startTime = Date.now();
      const content = currentRenderContent;
      const width = currentRenderWidth;
      const height = currentRenderHeight;

      // Pre-render text to an off-screen canvas
      const off = document.createElement('canvas');
      off.width = width;
      off.height = height;
      const offCtx = off.getContext('2d');

      const styles = content && content.styles ? content.styles : {};
      const textStyle = styles.text || {};
      const numberStyle = styles.number || styles.title || {};
      const referenceStyle = styles.reference || {};

      offCtx.clearRect(0, 0, width, height);
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';

      const padding = width * 0.02;
      const availableWidth = width - (padding * 2);
      const availableHeight = height - (padding * 2);
      let baseFontSize = height * 0.08;

      if (content.number) {
        offCtx.font = `${baseFontSize * 0.6}px Arial`;
        offCtx.textAlign = 'left';
        offCtx.fillStyle = numberStyle.color || '#fff';
        offCtx.fillText(content.number, padding, padding + baseFontSize * 0.3);
      }

      if (content.text) {
        offCtx.textAlign = 'center';
        const textY = height / 2;
        const textLines = content.text.split('\n');
        const allLines = [];

        textLines.forEach(textLine => {
          const segments = parseVerseSegments(textLine);
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          offCtx.font = `${baseFontSize}px Arial`;
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, offCtx);
          allLines.push(...wrappedLines);
        });

        let lines = allLines;
        while (true) {
          const testSize = baseFontSize + 4;
          offCtx.font = `${testSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, testSize, offCtx);
            testLines.push(...wrappedLines);
          });
          if (testLines.length * testSize * 1.2 < availableHeight * 0.85 && testSize < height * 0.15) {
            baseFontSize = testSize;
            lines = testLines;
          } else break;
        }

        while (lines.length * baseFontSize * 1.2 > availableHeight && baseFontSize > 20) {
          baseFontSize -= 2;
          offCtx.font = `${baseFontSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, offCtx);
            testLines.push(...wrappedLines);
          });
          lines = testLines;
        }

        const lineHeight = baseFontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        const startY = textY - (totalHeight / 2);
        lines.forEach((line, i) => {
          renderLineWithSubscripts(line, width / 2, startY + (i * lineHeight) + (baseFontSize / 2), baseFontSize, offCtx, { textColor: textStyle.color || '#fff', subscriptColor: textStyle.subscriptColor || (textStyle.color ? textStyle.color : '#ddd') });
        });
      }

      // Render reference if any
      if (content.reference) {
        offCtx.font = `${baseFontSize * 0.7}px Arial`;
        offCtx.textAlign = 'right';
        offCtx.fillStyle = referenceStyle.color || '#fff';
        offCtx.fillText(content.reference, width - padding, height - padding - baseFontSize * 0.3);
      }

      // Animate onto the text canvas
      function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; }

      const animate = () => {
        const elapsed = (Date.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        const eased = easeInOutCubic(progress);

        // Clear text canvas and draw with eased alpha/offset
        textCtx.clearRect(0, 0, width, height);
        if (animationType === 'fade') {
          textCtx.globalAlpha = eased;
          textCtx.drawImage(off, 0, 0);
          textCtx.globalAlpha = 1;
        } else if (animationType === 'slide-left') {
          const offset = (1 - eased) * width;
          textCtx.drawImage(off, offset, 0);
        } else if (animationType === 'slide-right') {
          const offset = (eased - 1) * width;
          textCtx.drawImage(off, offset, 0);
        } else if (animationType === 'slide-up') {
          const offset = (1 - eased) * height;
          textCtx.drawImage(off, 0, offset);
        } else if (animationType === 'slide-down') {
          const offset = (eased - 1) * height;
          textCtx.drawImage(off, 0, offset);
        }

        if (progress < 1) {
          currentAnimationFrameId = requestAnimationFrame(animate);
        } else {
          currentAnimationFrameId = null;
          textCtx.clearRect(0, 0, width, height);
          textCtx.drawImage(off, 0, 0);
          // Defensive: ensure watermark is present after fade-in completes
          try { drawLicenseWatermark(ctx, canvas); } catch (e) { console.warn('[live] drawLicenseWatermark failed after fade-in', e); }
          if (callback) callback();
        }
      };

      currentAnimationFrameId = requestAnimationFrame(animate);
    }
    
    // Helper: compare backgrounds (supports backgroundMedia and legacy backgroundPath)
    function backgroundsEqual(a, b) {
      if (!a && !b) return true;
      if (!a || !b) return false;

      // Handle explicit backgroundMedia first
      const am = a.backgroundMedia || (a.isMedia ? { type: a.mediaType, path: a.mediaPath, color: a.mediaColor } : null);
      const bm = b.backgroundMedia || (b.isMedia ? { type: b.mediaType, path: b.mediaPath, color: b.mediaColor } : null);

      if (am || bm) {
        if (!am || !bm) return false;
        if (am.type !== bm.type) return false;
        if (am.type === 'COLOR') return am.color === bm.color;
        if (am.path && bm.path) return am.path === bm.path;
        return false;
      }

      // Legacy backgroundPath or color
      if (a.backgroundPath || b.backgroundPath) {
        return (a.backgroundPath || '') === (b.backgroundPath || '');
      }

      return false;
    }

    // Helper: file URL helper that delegates to preload-exposed paths.fileUrlFor
    function _fileUrlFor(p) {
      try { if (window && window.paths && typeof window.paths.fileUrlFor === 'function') return window.paths.fileUrlFor(p); } catch (e) {}
      return 'file:///' + (p || '').replace(/\\/g, '/');
    }
    // Helper: render only the background portion of content to an offscreen canvas
    function renderBackgroundToCanvas(content, canvas) {
      return new Promise((resolve) => {
        const ctxLocal = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        ctxLocal.fillStyle = '#000';
        ctxLocal.fillRect(0, 0, width, height);

        // Prefer backgroundMedia, but also accept media fields from isMedia payloads
        let media = null;
        if (content) {
          media = content.backgroundMedia || null;
          if (!media && content.isMedia) {
            media = {
              type: content.mediaType,
              path: content.mediaPath,
              color: content.mediaColor,
              bgSize: content.bgSize,
              bgRepeat: content.bgRepeat,
              bgPosition: content.bgPosition
            };
          }
        }

        if (media && media.type === 'COLOR') {
          applyColorToCanvas(ctxLocal, media.color, width, height);
          resolve();
          return;
        }

        // Image or video background handling
        const pathToImg = media && media.path ? media.path : (content && content.backgroundPath ? content.backgroundPath : null);
        if (pathToImg) {
          // Determine if this is likely an image or video by extension (simple heuristic)
          const ext = (pathToImg.split('.').pop() || '').toLowerCase();
          const imageExts = ['jpg','jpeg','png','gif','webp','bmp'];
          const videoExts = ['mp4','webm','ogg','mov','avi'];

          if (imageExts.includes(ext)) {
            const img = new Image();
            img.onload = () => {
              drawImageWithSettings(ctxLocal, img, width, height, {
                bgSize: (media && media.bgSize) || 'cover',
                bgRepeat: (media && media.bgRepeat) || 'no-repeat',
                bgPosition: (media && media.bgPosition) || 'center'
              });
              resolve();
            };
            img.onerror = (e) => {
              console.warn('[live] renderBackgroundToCanvas image load failed:', pathToImg, e);
              // Fallback to black
              ctxLocal.fillStyle = '#000';
              ctxLocal.fillRect(0, 0, width, height);
              resolve();
            };
            // Ensure file:// URL for absolute paths
            img.src = _fileUrlFor(pathToImg);
            return;
          }

          if (videoExts.includes(ext)) {
            const video = document.createElement('video');
            video.preload = 'auto';
            video.muted = true;
            video.src = _fileUrlFor(pathToImg);
            // Wait for a frame to be available
            video.addEventListener('loadeddata', () => {
              try {
                // Draw current frame
                ctxLocal.drawImage(video, 0, 0, width, height);
              } catch (e) {
                // Drawing may fail on some codecs; fallback to black
                ctxLocal.fillStyle = '#000';
                ctxLocal.fillRect(0, 0, width, height);
              }
              resolve();
            });
            video.addEventListener('error', (e) => {
              console.warn('[live] renderBackgroundToCanvas video load failed:', pathToImg, e);
              ctxLocal.fillStyle = '#000';
              ctxLocal.fillRect(0, 0, width, height);
              resolve();
            });
            return;
          }

          // Unknown extension: try as image first
          const img = new Image();
          img.onload = () => {
            drawImageWithSettings(ctxLocal, img, width, height, {
              bgSize: (media && media.bgSize) || 'cover',
              bgRepeat: (media && media.bgRepeat) || 'no-repeat',
              bgPosition: (media && media.bgPosition) || 'center'
            });
            resolve();
          };
          img.onerror = () => {
            ctxLocal.fillStyle = '#000';
            ctxLocal.fillRect(0, 0, width, height);
            resolve();
          };
          img.src = _fileUrlFor(pathToImg);
          return;
        }

        // No media: nothing else to draw
        resolve();
      });
    }

    // Helper: render text-only to an offscreen canvas (same layout logic used elsewhere)
    function renderTextToCanvas(content) {
      const canvas = document.createElement('canvas');
      canvas.width = currentRenderWidth || window.innerWidth;
      canvas.height = currentRenderHeight || window.innerHeight;
      const textCtx = canvas.getContext('2d');
      textCtx.clearRect(0, 0, canvas.width, canvas.height);
      if (!content || !content.text) return canvas;

      textCtx.fillStyle = '#fff';
      textCtx.textAlign = 'center';
      textCtx.textBaseline = 'middle';
      const padding = canvas.width * 0.02;
      const availableWidth = canvas.width - (padding * 2);
      const availableHeight = canvas.height - (padding * 2);
      let baseFontSize = canvas.height * 0.08;

      // Verse number
      if (content.number) {
        textCtx.font = `${baseFontSize * 0.6}px Arial`;
        textCtx.textAlign = 'left';
        textCtx.fillText(content.number, padding, padding + baseFontSize * 0.3);
      }

      // Render verse text
      const textY = canvas.height / 2;
      const textLines = content.text.split('\n');
      const allLines = [];
      textLines.forEach(textLine => {
        const segments = parseVerseSegments(textLine);
        // Ensure inline markdown parsed for measurement/render
        segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
        textCtx.font = `${baseFontSize}px Arial`;
        const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
        allLines.push(...wrappedLines);
      });

      let lines = allLines;
      // Grow font if space
      while (true) {
        const testSize = baseFontSize + 4;
        textCtx.font = `${testSize}px Arial`;
        const testLines = [];
        textLines.forEach(textLine => {
          const segments = parseVerseSegments(textLine);
          // Ensure inline markdown is parsed for measurement
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, testSize, textCtx);
          testLines.push(...wrappedLines);
        });
        if (testLines.length * testSize * 1.2 < availableHeight * 0.85 && testSize < canvas.height * 0.15) {
          baseFontSize = testSize;
          lines = testLines;
        } else break;
      }

      while (lines.length * baseFontSize * 1.2 > availableHeight && baseFontSize > 20) {
        baseFontSize -= 2;
        textCtx.font = `${baseFontSize}px Arial`;
        const testLines = [];
        textLines.forEach(textLine => {
          const segments = parseVerseSegments(textLine);
          // Ensure inline markdown is parsed for measurement
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, textCtx);
          testLines.push(...wrappedLines);
        });
        lines = testLines;
      }

      // Draw lines
      const lineHeight = baseFontSize * 1.2;
      const totalHeight = lines.length * lineHeight;
      const startY = textY - (totalHeight / 2);
      lines.forEach((line, i) => {
        renderLineWithSubscripts(line, canvas.width / 2, startY + (i * lineHeight) + (baseFontSize / 2), baseFontSize, textCtx);
      });

      // Reference
      if (content.reference) {
        textCtx.font = `${baseFontSize * 0.7}px Arial`;
        textCtx.textAlign = 'right';
        textCtx.fillText(content.reference, canvas.width - padding, canvas.height - padding - baseFontSize * 0.3);
      }

      return canvas;
    }

    // Apply a simple background cross-fade between two contents (text remains on top)
    async function applyBackgroundCrossfade(oldContent, newContent, duration = 0.4) {
      // Cancel any ongoing animations
      if (currentAnimationFrameId) {
        cancelAnimationFrame(currentAnimationFrameId);
        currentAnimationFrameId = null;
      }

      const width = canvas.width;
      const height = canvas.height;

      const oldBgCanvas = document.createElement('canvas');
      oldBgCanvas.width = width; oldBgCanvas.height = height;
      const newBgCanvas = document.createElement('canvas');
      newBgCanvas.width = width; newBgCanvas.height = height;

      // Render both backgrounds (await images to load when necessary)
      await Promise.all([
        renderBackgroundToCanvas(oldContent, oldBgCanvas),
        renderBackgroundToCanvas(newContent, newBgCanvas)
      ]);

      // Pre-render text: keep the currently visible text stable during the background fade.
      // If old content has visible text, prefer that; otherwise fall back to newContent.
      const textSource = (oldContent && oldContent.text) ? oldContent : newContent;
      const textCanvas = renderTextToCanvas(textSource);

      const startTime = Date.now();
      function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; }

      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / (duration * 1000), 1);
        const eased = easeInOutCubic(progress);

        // Draw blended backgrounds
        ctx.clearRect(0, 0, width, height);
        ctx.globalAlpha = 1;

        // Draw old bg with (1 - eased)
        if (eased < 1) {
          ctx.globalAlpha = 1 - eased;
          ctx.drawImage(oldBgCanvas, 0, 0);
        }
        // Draw new bg with eased
        ctx.globalAlpha = eased;
        ctx.drawImage(newBgCanvas, 0, 0);
        ctx.globalAlpha = 1;

        // Draw watermark between background and text so it stays visible during crossfade
        drawLicenseWatermark(ctx, canvas);

        // Draw text on top
        if (textCanvas) ctx.drawImage(textCanvas, 0, 0);

        if (progress < 1) {
          currentAnimationFrameId = requestAnimationFrame(animate);
        } else {
          currentAnimationFrameId = null;
        }
      };

      currentAnimationFrameId = requestAnimationFrame(animate);
    }

    /**
     * Render verse content to canvas
     */
    function renderContent(renderContent_content) {
      window.currentContent = renderContent_content;
      
      console.log('Live window renderContent called with:', renderContent_content);
      
      const width = canvas.width;
      const height = canvas.height;
      
      // IMPORTANT: Store OLD content before updating currentRenderContent
      const oldContent = currentRenderContent ? { ...currentRenderContent } : null;
      
      // Store in module-level variables for helper functions
      currentRenderContent = renderContent_content;
      currentRenderWidth = width;
      currentRenderHeight = height;
      
      // If only the background changed, perform a background-only crossfade and keep text
      if (oldContent && !backgroundsEqual(oldContent, renderContent_content)) {
        const dur = (renderContent_content && renderContent_content.transitionIn && renderContent_content.transitionIn.duration) ? renderContent_content.transitionIn.duration : 0.4;
        applyBackgroundCrossfade(oldContent, renderContent_content, dur);
        // Don't continue with normal rendering (crossfade draws the backgrounds and text)
        // Store previous content for future out transitions
        window.previousContent = renderContent_content;
        return;
      }
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);
      
      // Handle media content
      if (renderContent_content.isMedia) {
        console.log('Rendering media - type:', renderContent_content.mediaType);
        const isImage = ['JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'BMP'].includes(renderContent_content.mediaType);
        const isVideo = ['MP4', 'WEBM', 'OGG', 'MOV', 'AVI'].includes(renderContent_content.mediaType);
        const isColor = renderContent_content.mediaType === 'COLOR';
        
        console.log('Media flags - isImage:', isImage, 'isVideo:', isVideo, 'isColor:', isColor);
        
        if (isColor) {
          console.log('Applying color:', renderContent_content.mediaColor);
          // Apply color or gradient
          applyColorToCanvas(ctx, renderContent_content.mediaColor, width, height);
          // Ensure watermark is drawn onto the background for unlicensed state
          drawLicenseWatermark(ctx, canvas);
          // Media content appears instantly, no text fade needed
        } else if (isImage) {
          console.log('Loading image with settings:', {
            bgSize: renderContent_content.bgSize,
            bgRepeat: renderContent_content.bgRepeat,
            bgPosition: renderContent_content.bgPosition
          });
          const img = new Image();
          img.onload = () => {
            // Black is fallback - render first
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            drawImageWithSettings(ctx, img, width, height, {
              bgSize: renderContent_content.bgSize,
              bgRepeat: renderContent_content.bgRepeat,
              bgPosition: renderContent_content.bgPosition
            });
            // Draw watermark after rendering the image background
            drawLicenseWatermark(ctx, canvas);
            // Media content appears instantly, no text fade needed
          };
          img.onerror = (e) => console.error('Failed to load image:', content.mediaPath, e);
          const fileURL = renderContent_content.mediaPath;
          img.src = _fileUrlFor(fileURL);
        } else if (isVideo) {
          // Stop any existing video first
          if (window.currentVideo) {
            window.currentVideo.pause();
            window.currentVideo = null;
          }
          
          const video = document.createElement('video');
          const fileURL = renderContent_content.mediaPath;
          video.src = _fileUrlFor(fileURL);
          video.loop = renderContent_content.loop !== false; // default true
          video.muted = renderContent_content.muted !== false; // default true
          video.play();
          window.currentVideo = video;
          
          const objectFit = renderContent_content.objectFit || 'contain';
          
          const drawFrame = () => {
            if (window.currentVideo !== video) return; // Stop if video changed
            if (video.readyState >= 2) {
              let scale, w, h, x, y;
              
              if (objectFit === 'fill') {
                w = width;
                h = height;
                x = 0;
                y = 0;
              } else if (objectFit === 'cover') {
                scale = Math.max(width / video.videoWidth, height / video.videoHeight);
                w = video.videoWidth * scale;
                h = video.videoHeight * scale;
                x = (width - w) / 2;
                y = (height - h) / 2;
              } else if (objectFit === 'none') {
                w = video.videoWidth;
                h = video.videoHeight;
                x = (width - w) / 2;
                y = (height - h) / 2;
              } else { // contain (default)
                scale = Math.min(width / video.videoWidth, height / video.videoHeight);
                w = video.videoWidth * scale;
                h = video.videoHeight * scale;
                x = (width - w) / 2;
                y = (height - h) / 2;
              }
              
              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(video, x, y, w, h);
              // Draw watermark on each video frame so transitions capture it
              drawLicenseWatermark();
            }
            requestAnimationFrame(drawFrame);
          };
          drawFrame();
        }
        return;
      }
      
      // Verse/text content rendering
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Function to render background and show text
      const showTextWithAnimation = () => {
        // Store previous content for transition-out animation on next call
        const hasPreviousContent = window.previousContent && 
                                   window.previousContent.text && 
                                   renderContent_content.text && 
                                   window.previousContent !== renderContent_content;
        
        if (hasPreviousContent) {
          // Use previous content's transitionOut if provided, otherwise fall back to transitionIn
          const transitionOut = window.previousContent.transitionOut || window.previousContent.transitionIn || { duration: 0.4, type: 'fade' };
          
          // Fade out old content, then fade in new content
          applyTextFadeOutAnimation(
            oldContent,
            transitionOut.duration,
            transitionOut.type || 'fade',
            () => {
              // After fade-out completes, re-render the background before fade-in
              // Black background is the fallback - render it first
              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, width, height);
              
              if (renderContent_content.backgroundMedia) {
                const media = renderContent_content.backgroundMedia;
                if (media.type === 'COLOR') {
                  applyColorToCanvas(ctx, media.color, width, height);
                  // Reapply watermark after redrawing the background color
                  drawLicenseWatermark(ctx, canvas);
                } else if (media.type === 'JPG' || media.type === 'PNG') {
                  // Image background - redraw it
                  const bgImg = new Image();
                  bgImg.onload = () => {
                    drawImageWithSettings(ctx, bgImg, width, height, {
                      bgSize: media.bgSize || 'cover',
                      bgRepeat: media.bgRepeat || 'no-repeat',
                      bgPosition: media.bgPosition || 'center'
                    });
                    // Reapply watermark after redrawing the background image
                    drawLicenseWatermark(ctx, canvas);
                    
                    // Now start fade-in with background in place
                    if (renderContent_content.transitionIn) {
                      applyTextFadeInAnimation(
                        renderContent_content.transitionIn.duration,
                        renderContent_content.transitionIn.type || 'fade'
                      );
                    }
                  };
                  const fileURL = media.path;
                  bgImg.src = _fileUrlFor(fileURL);
                  return; // Don't call fade-in below
                }
              }
              
              // Apply fade-in after background is ready
              if (renderContent_content.transitionIn) {
                applyTextFadeInAnimation(
                  renderContent_content.transitionIn.duration,
                  renderContent_content.transitionIn.type || 'fade'
                );
              }
            }
          );
        } else {
          // No fade-out needed, ensure watermark is present then apply fade-in
          drawLicenseWatermark();
          if (renderContent_content.transitionIn) {
            applyTextFadeInAnimation(
              renderContent_content.transitionIn.duration,
              renderContent_content.transitionIn.type || 'fade'
            );
          }
        }
      };
      
      // Handle background media (object with type, path, color, and settings)
      if (renderContent_content.backgroundMedia) {
        const media = renderContent_content.backgroundMedia;
        
        if (media.type === 'COLOR') {
          // Black is fallback - render first
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, width, height);
          
          applyColorToCanvas(ctx, media.color, width, height);
          // Draw watermark between background and text
          drawLicenseWatermark();
          showTextWithAnimation();
        } else if (media.type === 'JPG' || media.type === 'PNG') {
          console.log('Live window: Loading image background with settings:', media);
          const bgImg = new Image();
          bgImg.onload = () => {
            // Black is fallback - render first
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            drawImageWithSettings(ctx, bgImg, width, height, {
              bgSize: media.bgSize || 'cover',
              bgRepeat: media.bgRepeat || 'no-repeat',
              bgPosition: media.bgPosition || 'center'
            });
            // Draw watermark between background and text
            drawLicenseWatermark();
            
            showTextWithAnimation();
          };
          bgImg.onerror = (e) => {
            console.error('Live window failed to load background:', media.path, e);
            showTextWithAnimation();
          };
          const fileURL = media.path;
          bgImg.src = _fileUrlFor(fileURL);
        } else {
          // Video or unknown type - just show text with animation
          showTextWithAnimation();
        }
      } else if (renderContent_content.backgroundPath) {
        // Legacy path string support
        console.log('Live window: Background path provided:', renderContent_content.backgroundPath);
        const bgImg = new Image();
        const fileURL = renderContent_content.backgroundPath;
        console.log('Live window: Loading background from:', fileURL);
        bgImg.onload = () => {
          console.log('Live window: Background loaded successfully');
          const scale = Math.min(width / bgImg.width, height / bgImg.height);
          const w = bgImg.width * scale;
          const h = bgImg.height * scale;
          const x = (width - w) / 2;
          const y = (height - h) / 2;
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(bgImg, x, y, w, h);
          console.log('Live window: Background drawn, no overlay darkening');
          // Draw watermark between background and text
          drawLicenseWatermark();
          
          // Show text with animation
          console.log('Live window: Showing text with animation');
          showTextWithAnimation();
        };
        bgImg.onerror = (e) => {
          console.error('Live window failed to load background:', renderContent_content.backgroundPath, e);
          showTextWithAnimation();
        };
        bgImg.src = _fileUrlFor(fileURL);
      } else {
        console.log('Live window: No background, rendering text only');
        showTextWithAnimation();
      }
      
      // Store this content for transition-out on next call
      window.previousContent = renderContent_content;
    }
    
    /**
     * Parse text into segments of verse numbers and text
     */
    function parseVerseSegments(text) {
      const segments = [];
      const regex = /(\d+)\s{2}/g;
      let lastIndex = 0;
      let match;
      
      while ((match = regex.exec(text)) !== null) {
        if (match.index > lastIndex) {
          const textBefore = text.substring(lastIndex, match.index).trim();
          if (textBefore) segments.push({ isNumber: false, text: textBefore });
        }
        segments.push({ isNumber: true, text: match[1] });
        lastIndex = regex.lastIndex;
      }
      
      if (lastIndex < text.length) {
        const remaining = text.substring(lastIndex).trim();
        if (remaining) segments.push({ isNumber: false, text: remaining });
      }
      
      return segments;
    }

    // Parse inline Markdown in a string into an array of word objects with style flags
    // Supports: **bold**, __bold__, *italic*, _italic_
    function parseInlineMarkdownWords(s) {
      const out = [];
      if (!s) return out;

      const tokenRegex = /(\*\*|__)([\s\S]+?)\1|(\*|_)([\s\S]+?)\3/g;
      let lastIndex = 0;
      let m;

      while ((m = tokenRegex.exec(s)) !== null) {
        if (m.index > lastIndex) {
          const plain = s.substring(lastIndex, m.index);
          plain.split(' ').forEach((w, i, arr) => {
            if (w === '') return;
            const add = i < arr.length - 1 ? w + ' ' : w;
            out.push({ text: add, bold: false, italic: false });
          });
        }

        if (m[1] && m[2]) {
          // Bold
          m[2].split(' ').forEach((w, i, arr) => {
            if (w === '') return;
            const add = i < arr.length - 1 ? w + ' ' : w;
            out.push({ text: add, bold: true, italic: false });
          });
        } else if (m[3] && m[4]) {
          // Italic
          m[4].split(' ').forEach((w, i, arr) => {
            if (w === '') return;
            const add = i < arr.length - 1 ? w + ' ' : w;
            out.push({ text: add, bold: false, italic: true });
          });
        }

        lastIndex = tokenRegex.lastIndex;
      }

      if (lastIndex < s.length) {
        const rest = s.substring(lastIndex);
        rest.split(' ').forEach((w, i, arr) => {
          if (w === '') return;
          const add = i < arr.length - 1 ? w + ' ' : w;
          out.push({ text: add, bold: false, italic: false });
        });
      }

      if (out.length === 0 && s.trim() !== '') out.push({ text: s, bold: false, italic: false });
      return out;
    }
    
    /**
     * Wrap text with subscript segments
     */
    function wrapTextWithSubscripts(segments, maxWidth, baseFontSize, context = ctx) {
      const lines = [];
      let currentLine = [];
      let currentWidth = 0;
      
      const subscriptSize = baseFontSize * 0.6;
      
      segments.forEach(seg => {
        if (seg.isNumber) {
          context.font = `${subscriptSize}px Arial`;
          const width = context.measureText(seg.text + ' ').width;
          
          if (currentWidth + width > maxWidth && currentLine.length > 0) {
            lines.push(currentLine);
            currentLine = [];
            currentWidth = 0;
          }
          
          currentLine.push(seg);
          currentWidth += width;
          context.font = `${baseFontSize}px Arial`;
        } else {
          // Use parsed words (with bold/italic flags) if available
          const words = seg.words ? seg.words : seg.text.split(' ');
          words.forEach((wordObj, idx) => {
            const wordText = typeof wordObj === 'string' ? wordObj : wordObj.text;
            const testWord = wordText + (idx < words.length - 1 ? ' ' : '');

            // Measure using style-aware font if available
            if (typeof wordObj !== 'string') {
              const fontStr = `${wordObj.italic ? 'italic ' : ''}${wordObj.bold ? 'bold ' : ''}${baseFontSize}px Arial`;
              context.font = fontStr;
            } else {
              context.font = `${baseFontSize}px Arial`;
            }

            const width = context.measureText(testWord).width;
            if (currentWidth + width > maxWidth && currentLine.length > 0) {
              lines.push(currentLine);
              currentLine = [];
              currentWidth = 0;
            }

            if (typeof wordObj === 'string') {
              currentLine.push({ isNumber: false, text: testWord });
            } else {
              currentLine.push({ isNumber: false, text: testWord, bold: !!wordObj.bold, italic: !!wordObj.italic });
            }
            currentWidth += width;
          });
        }
      });
      
      if (currentLine.length > 0) {
        lines.push(currentLine);
      }
      
      return lines;
    }
    
    /**
     * Render a line with subscript verse numbers
     */
    function renderLineWithSubscripts(segments, centerX, y, baseFontSize, context = ctx, colors = {}) {
      const subscriptSize = baseFontSize * 0.6;
      let totalWidth = 0;
      
      segments.forEach(seg => {
        if (seg.isNumber) {
          context.font = `${subscriptSize}px Arial`;
          totalWidth += context.measureText(seg.text + ' ').width;
        } else {
          context.font = `${baseFontSize}px Arial`;
          totalWidth += context.measureText(seg.text).width;
        }
      });
      
      let x = centerX - (totalWidth / 2);
      
      context.textBaseline = 'alphabetic';  // Use alphabetic baseline for consistent rendering
      
      segments.forEach(seg => {
        if (seg.isNumber) {
          context.font = `${subscriptSize}px Arial`;
          context.fillStyle = colors.subscriptColor || '#ddd';
          context.textAlign = 'left';
          context.fillText(seg.text + ' ', x, y + (baseFontSize * 0.2));
          x += context.measureText(seg.text + ' ').width;
          context.fillStyle = colors.textColor || '#fff';
        } else {
          // Honor per-segment bold/italic flags when rendering
          const fontStr = `${seg && seg.italic ? 'italic ' : ''}${seg && seg.bold ? 'bold ' : ''}${baseFontSize}px Arial`;
          context.font = fontStr;
          context.textAlign = 'left';
          context.fillStyle = colors.textColor || '#fff';
          context.fillText(seg.text, x, y);
          x += context.measureText(seg.text).width;
        }
      });
      
      context.textBaseline = 'middle';  // Reset to middle
    }
    
    /**
     * Render text content to canvas
     */
    function renderTextOnCanvas() {
      const width = currentRenderWidth;
      const height = currentRenderHeight;
      const content = currentRenderContent;
      const styles = content && content.styles ? content.styles : {};
      const textStyle = styles.text || {};
      const numberStyle = styles.number || styles.title || {};
      const referenceStyle = styles.reference || {};
      
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
    
      const padding = width * 0.02;
      const availableWidth = width - (padding * 2);
      const availableHeight = height - (padding * 2);
      
      // Calculate font sizes
      let baseFontSize = height * 0.08;
      
      // Render verse number (top left)
      if (content.number) {
        ctx.font = `${baseFontSize * 0.6}px Arial`;
        ctx.textAlign = 'left';
        ctx.fillStyle = numberStyle.color || '#fff';
        ctx.fillText(content.number, padding, padding + baseFontSize * 0.3);
      }
      
      // Render verse text (center)
      if (content.text) {
        ctx.textAlign = 'center';
        const textY = height / 2;
        
        // Default text color and subscript color
        const normalTextColor = textStyle.color || '#fff';
        const subscriptColor = textStyle.subscriptColor || (textStyle.color ? textStyle.color : '#ddd');
        
        // Split text by explicit newlines first (for songs), then handle verse numbers
        const textLines = content.text.split('\n');
        const allLines = [];
        
        textLines.forEach(textLine => {
                // Parse text to handle verse numbers as subscripts
          const segments = parseVerseSegments(textLine);
          // Parse inline markdown for each non-number segment so we can render bold/italic on canvas
          segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
          
          // Auto-size font to fill vertical space optimally
          ctx.font = `${baseFontSize}px Arial`;
          const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize, ctx);
          allLines.push(...wrappedLines);
        });
        
        let lines = allLines;
        
        // Grow font size to fill available vertical space
        while (true) {
          const testSize = baseFontSize + 4;
          ctx.font = `${testSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
              const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, testSize);
            testLines.push(...wrappedLines);
          });
          if (testLines.length * testSize * 1.2 < availableHeight * 0.85 && testSize < height * 0.15) {
            baseFontSize = testSize;
            lines = testLines;
          } else {
            break;
          }
        }
        
        // If we overshot, shrink back down
        while (lines.length * baseFontSize * 1.2 > availableHeight && baseFontSize > 20) {
          baseFontSize -= 2;
          ctx.font = `${baseFontSize}px Arial`;
          const testLines = [];
          textLines.forEach(textLine => {
            const segments = parseVerseSegments(textLine);
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            segments.forEach(s => { if (!s.isNumber) s.words = parseInlineMarkdownWords(s.text); });
            const wrappedLines = wrapTextWithSubscripts(segments, availableWidth, baseFontSize);
            testLines.push(...wrappedLines);
          });
          lines = testLines;
        }
        
        // Render lines with subscript numbers
        const lineHeight = baseFontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        const startY = textY - (totalHeight / 2);
        
        lines.forEach((line, i) => {
          renderLineWithSubscripts(line, width / 2, startY + (i * lineHeight) + (baseFontSize / 2), baseFontSize, ctx, { textColor: normalTextColor, subscriptColor });
        });
      }
      
      // Render reference (bottom right)
      if (content.reference) {
        ctx.font = `${baseFontSize * 0.7}px Arial`;
        ctx.textAlign = 'right';
        ctx.fillStyle = referenceStyle.color || '#fff';
        ctx.fillText(content.reference, width - padding, height - padding - baseFontSize * 0.3);
      }
      
      // Render hint (if showing clipped verses)
      if (content.showingCount && content.totalSelected && content.showingCount < content.totalSelected) {
        const hint = `Showing ${content.showingCount} of ${content.totalSelected} selected`;
        ctx.font = `${baseFontSize * 0.6}px Arial`;
        ctx.fillStyle = '#ddd';
        ctx.textAlign = 'right';
        ctx.fillText(hint, width - padding, height - padding - baseFontSize * 1.1);
        ctx.fillStyle = '#fff';
      }
    }
    
    /**
     * Render content to canvas
     */
    
    // Unified mode setter for clear/black/normal; centralizes transitions and avoids IPC races
    function setLiveMode(mode) {
      console.debug('[live] setLiveMode ->', mode);
      // Cancel any ongoing animations
      if (currentAnimationFrameId) {
        cancelAnimationFrame(currentAnimationFrameId);
        currentAnimationFrameId = null;
      }

      if (mode === 'black') {
        console.debug('[live] entering black mode');
        isClearMode = false;
        isBlackMode = true;
        // Fill background black and clear the text layer so no text remains visible
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        try { textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height); } catch (e) { /* ignore if textCtx unavailable */ }
        currentRenderContent = window.currentContent ? { ...window.currentContent, number: '', text: '', reference: '' } : null;
        return;
      }

      if (mode === 'clear') {
        // If already clear, no-op
        if (isClearMode) return;
        isClearMode = true;
        isBlackMode = false;

        // If there's visible text on screen, fade it out; otherwise just show background
        const hasVisibleText = currentRenderContent && currentRenderContent.text;
        const width = canvas.width;
        const height = canvas.height;
        const transitionSettings = window.currentContent && window.currentContent.transitionIn ? window.currentContent.transitionIn : { duration: 0.4, type: 'fade' };

        const renderBackground = () => {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, width, height);
          if (window.currentContent && window.currentContent.backgroundMedia) {
            const media = window.currentContent.backgroundMedia;
            if (media.type === 'COLOR') {
              applyColorToCanvas(ctx, media.color, width, height);
            } else if (media.type === 'JPG' || media.type === 'PNG') {
              const bgImg = new Image();
              bgImg.onload = () => drawImageWithSettings(ctx, bgImg, width, height, { bgSize: media.bgSize || 'cover', bgRepeat: media.bgRepeat || 'no-repeat', bgPosition: media.bgPosition || 'center' });
              const fileURL = media.path;
              bgImg.src = _fileUrlFor(fileURL);
            }
          }
        };

        if (hasVisibleText) {
          const oldContent = { ...currentRenderContent };
          renderBackground();
          // Ensure watermark is drawn into the captured background for the fade-out
          drawLicenseWatermark();
          applyTextFadeOutAnimation(oldContent, transitionSettings.duration, transitionSettings.type || 'fade', () => {
            // After fade-out finishes, clear the text layer to ensure no residual remains
            try { textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height); } catch (e) { /* ignore */ }
            currentRenderContent = window.currentContent ? { ...window.currentContent, number: '', text: '', reference: '' } : null;
          });
        } else {
          renderBackground();
          // Draw watermark for clear-mode background
          drawLicenseWatermark();
          // Ensure text layer is cleared immediately
          try { textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height); } catch (e) { /* ignore */ }
          currentRenderContent = window.currentContent ? { ...window.currentContent, number: '', text: '', reference: '' } : null;
        }

        return;
      }

      // mode === 'normal'
      isClearMode = false;
      isBlackMode = false;
      if (window.currentContent) renderContent(window.currentContent);
    }

    ipcRenderer.on('update-content', (event, data) => {
      // Update underlying content data
      window.currentContent = data;

      // Respect current mode: keep screen black or cleared if those modes are active
      if (isBlackMode) {
        // Keep black screen; currentRenderContent should reflect no text
        const width = canvas.width;
        const height = canvas.height;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        // Draw watermark on black screen
        drawLicenseWatermark();
        currentRenderContent = {
          ...window.currentContent,
          number: '',
          text: '',
          reference: ''
        };
        return;
      }

      if (isClearMode) {
        // Keep background visible but no text
        const width = canvas.width;
        const height = canvas.height;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        if (window.currentContent && window.currentContent.backgroundMedia) {
          const media = window.currentContent.backgroundMedia;
          if (media.type === 'COLOR') {
            applyColorToCanvas(ctx, media.color, width, height);
          } else if (media.type === 'JPG' || media.type === 'PNG') {
            const bgImg = new Image();
            bgImg.onload = () => {
              drawImageWithSettings(ctx, bgImg, width, height, {
                bgSize: media.bgSize || 'cover',
                bgRepeat: media.bgRepeat || 'no-repeat',
                bgPosition: media.bgPosition || 'center'
              });
            };
            const fileURL = media.path;
            bgImg.src = _fileUrlFor(fileURL);
          }
        }
        currentRenderContent = {
          ...window.currentContent,
          number: '',
          text: '',
          reference: ''
        };
        return;
      }

      // Default: render normally
      renderContent(data);
    });
    
    // Legacy handler delegates to setLiveMode
    ipcRenderer.on('clear-live-text', () => setLiveMode('clear'));

    // Legacy set-live-black delegates to setLiveMode
    ipcRenderer.on('set-live-black', () => setLiveMode('black'));

    // Legacy reset-live-canvas delegates to normal mode
    ipcRenderer.on('reset-live-canvas', () => setLiveMode('normal'));

    // New unified mode handler
    ipcRenderer.on('set-live-mode', (event, mode) => setLiveMode(mode));
    
    ipcRenderer.on('show-live-text', () => {
      // Cancel any ongoing animations
      if (currentAnimationFrameId) {
        cancelAnimationFrame(currentAnimationFrameId);
        currentAnimationFrameId = null;
      }
      
      isClearMode = false;
      isBlackMode = false;
      
      if (window.currentContent) {
        // Restore content with fade-in transition
        const width = canvas.width;
        const height = canvas.height;
        
        // Update currentRenderContent first
        currentRenderContent = window.currentContent;
        currentRenderWidth = width;
        currentRenderHeight = height;
        
        // Render background first
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        if (window.currentContent.backgroundMedia) {
          const media = window.currentContent.backgroundMedia;
          if (media.type === 'COLOR') {
            applyColorToCanvas(ctx, media.color, width, height);
            // Draw watermark between background and text
            drawLicenseWatermark();
            // Then fade in text
            if (window.currentContent.transitionIn) {
              applyTextFadeInAnimation(
                window.currentContent.transitionIn.duration,
                window.currentContent.transitionIn.type || 'fade'
              );
            }
          } else if (media.type === 'JPG' || media.type === 'PNG') {
            const bgImg = new Image();
            bgImg.onload = () => {
              drawImageWithSettings(ctx, bgImg, width, height, {
                bgSize: media.bgSize || 'cover',
                bgRepeat: media.bgRepeat || 'no-repeat',
                bgPosition: media.bgPosition || 'center'
              });
              // Draw watermark between background and text
              drawLicenseWatermark();
              // Then fade in text
              if (window.currentContent.transitionIn) {
                applyTextFadeInAnimation(
                  window.currentContent.transitionIn.duration,
                  window.currentContent.transitionIn.type || 'fade'
                );
              }
            };
            const fileURL = media.path;
            bgImg.src = _fileUrlFor(fileURL);
          }
        } else {
          // No background media, draw watermark then fade in text
          drawLicenseWatermark();
          if (window.currentContent.transitionIn) {
            applyTextFadeInAnimation(
              window.currentContent.transitionIn.duration,
              window.currentContent.transitionIn.type || 'fade'
            );
          }
        }
      }
    });
    
    ipcRenderer.on('set-live-black', () => {
      // Cancel any ongoing animations
      if (currentAnimationFrameId) {
        cancelAnimationFrame(currentAnimationFrameId);
        currentAnimationFrameId = null;
      }
      
      isClearMode = false;
      isBlackMode = true;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Draw watermark after background fill so it appears under any text drawn later
      drawLicenseWatermark();
    });
    
    ipcRenderer.on('reset-live-canvas', () => {
      // Cancel any ongoing animations
      if (currentAnimationFrameId) {
        cancelAnimationFrame(currentAnimationFrameId);
        currentAnimationFrameId = null;
      }
      
      isClearMode = false;
      isBlackMode = false;
      if (window.currentContent) {
        renderContent(window.currentContent);
        // renderContent will call show-live-text logic which will draw watermark between background and text
      } else {
        // still ensure watermark is visible over background-only states
        drawLicenseWatermark();
      }
    });
  </script>
</body>
</html>


